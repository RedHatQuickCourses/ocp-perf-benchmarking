= Configuring kube-burner jobs to simulate cluster churn

== Understanding and setting up cluster churn simulation with kube-burner

Kube-burner, a Golang-based tool, is designed to stress Kubernetes clusters by creating, deleting, and patching resources at a specified rate. This feature makes it an ideal instrument for simulating cluster churn â€“ the process of adding or removing significant numbers of pods, services, or other objects in a short period, which can impact the control plane's responsiveness.

To configure kube-burner jobs for simulating cluster churn, you need to define specific settings within its configuration file or via command line flags. This section will guide you through these configurations step by step using practical examples.

### Configuration basics

Start by understanding the global and job-specific settings in your kube-burner configuration file (`kube-burner.yaml` or provided as a flag when invoking `kube-burner init`). Here are some key parameters to consider:

#### Global settings

- `writeToFile`: A boolean that determines if metrics should be written to files (default is `true`).
- `metricsDirectory`: The directory where collected metrics will be stored (default is `collected-metrics`).

#### Job-specific settings

- `name`: A unique identifier for the job.
- `jobIterations`: The number of times this job should run.
- `qps` (Queries Per Second): Controls the rate at which operations are performed (e.g., creating or deleting objects).
- `burst`: Specifies the maximum burst above the qps rate.
- `namespacedIterations`: A boolean to indicate if iterations should be namespace-specific.
- `cleanup`: Determines whether resources created during a job iteration should be cleaned up afterward.
- `namespace`: The target namespace for the job's operations.
- `jobPause`: The duration between successive iterations of the job.
- `objects`: An array specifying object templates and their configurations, including the number of replicas.

### Configuring cluster churn simulation

To simulate cluster churn, we'll focus on creating and deleting objects (e.g., deployments) rapidly. Here's an example configuration:

```yaml
global:
  writeToFile: true
  metricsDirectory: collected-metrics
jobs:
  - name: cluster-churn-job
    jobIterations: 5
    qps: 20
    burst: 40
    namespacedIterations: true
    cleanup: true
    namespace: kube-burner-job-ns
    jobPause: 1s
    objects:
      - objectTemplate: objectTemplates/deployment.yml
        replicas: 1
```

In this setup:

- We define a job named `cluster-churn-job`.
- The job will run five iterations (`jobIterations`).
- It aims to create or delete resources at a rate of 20 operations per second (`qps`) with occasional bursts up to 40 operations/second (`burst`).
- Each iteration occurs in a different namespace (`namespacedIterations` is set to `true`), allowing for targeted churn testing.
- Resources are cleaned up after each iteration (`cleanup: true`).
- The job pauses for one second between iterations (`jobPause: 1s`) to avoid overwhelming the control plane and measure its responsiveness accurately.
- A single deployment object with one replica is created per iteration (`objects`).

### Running the simulation

Execute kube-burner with your configuration file using the following command:

```bash
kube-burner init -f kube-burner.yaml
```

Kube-burner will start simulating cluster churn according to your defined parameters, allowing you to observe and measure the control plane's responsiveness under load.

### Conclusion

By carefully configuring kube-burner jobs, you can simulate realistic cluster churn scenarios and assess how well your Kubernetes control plane performs under various stress conditions. Remember to adjust parameters like `qps`, `burst`, and object types as needed for targeted testing in diverse environments.
