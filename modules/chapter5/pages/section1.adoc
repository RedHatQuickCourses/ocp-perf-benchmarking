= Configuring kube-burner jobs to simulate cluster churn

Cluster churn is a critical real-world behavior where workloads are continuously created and deleted. Simulating this behavior helps uncover issues in scheduling, garbage collection, API performance, controller reconciliation, and control-plane stability. kube-burner provides native support for controlled workload churning to model these conditions at scale.

This tutorial walks you through what churn is, how it works, and exactly how to configure it in kube-burner.

### 1. What is `churn` in kube-burner?

In kube-burner, churn refers to the cyclic deletion and re-creation of workloads after the initial job completes. 

*Churning*:

* Randomly selects a subset of namespaces or objects
* Deletes them
* Recreates them using the original job templates
* Repeats this process for a defined duration or number of cycles

*This simulates*:

* Auto-scaling environments
* CI/CD redeployments
* Unstable or bursty workloads
* Real-world production traffic patterns

⚠️ Important: Churn is supported only for create jobs and only for namespace-based jobs.

### 2. When should you use churn?

You should enable churning when testing:

* API server behavior under continuous load
* Scheduler and controller stability
* Namespace lifecycle performance
* Garbage collection efficiency
* Control plane memory and CPU leaks
* Network and CNI stability under load

Churn is especially valuable for:

* Long-running soak tests
* Scale-down/scale-up stress tests
* Multi-tenant simulation environments

### 3. Basic churn configuration example

The example below:

* Creates 100 namespaces
* Churns 20% of them
* Runs for 2 hours
* Recreates 10 Deployments and 10 Services per namespace

```
jobs:
- name: churning-job
  jobIterations: 100
  namespacedIterations: true
  namespace: churn-test

  churnConfig:
    percent: 20
    duration: 2h

  objects:
  - objectTemplate: deployment.yml
    replicas: 10

  - objectTemplate: service.yml
    replicas: 10
```
*What Happens Here?*

1. kube-burner creates 100 namespaces
2. Each namespace gets:

* 10 Deployments
* 10 Services
3. After job completion:

* 20 namespaces (20%) are randomly selected
* They are deleted and recreated
4. This cycle continues for 2 hours

### 4. Churn termination conditions

Churn stops when either condition is met first:

* `duration` - Total time to keep churning
* `cycles` - Total number of churn cycles

*Example: Cycle-based churn only*
```
churnConfig:
  percent: 30
  cycles: 10
```
Churn runs exactly 10 iterations, regardless of time.

*Example: Duration-based churn only*
```
churnConfig:
  percent: 25
  duration: 1h
  cycles: 0
```
Churn runs only by time, ignoring cycles.

### 5. Churn delay between cycles
You can pause between churn operations using `delay`:
```
churnConfig:
  percent: 20
  duration: 1h
  delay: 2m
```
Each churn wave waits 2 minutes before starting the next delete/recreate cycle.

### 6. Namespace vs Object churn modes
By default, kube-burner churns entire namespaces. You can 
switch to object-level churn with `mode: objects`.

*Namespace Churn (Default)*
```
churnConfig:
  percent: 20
  mode: namespaces

```
* Deletes and recreates entire namespaces
* Heaviest load on API server and controllers

*Object-level Churn*
```
churnConfig:
  percent: 20
  mode: objects
```
* Deletes objects only inside namespaces
* Namespaces remain intact
* Better for application-level chaos testing

### 7. Excluding Specific Objects from Churn
Some objects should never be deleted, such as:

* RBAC
* CRDs
* Storage classes
* Base networking objects

You can disable churn per object:
```
objects:
- objectTemplate: deployment.yml
  replicas: 10
  churn: false

- objectTemplate: service.yml
  replicas: 10
```
The Deployment will never be deleted during churn, but Services will.

### 8. Full Advanced Churn Example
This configuration:

* Creates 200 namespaces
* Churns 15% of them
* Runs for 90 minutes
* Waits 1 minute between churn cycles
* Churns only objects
* Protects one critical object
```
jobs:
- name: advanced-churn
  jobIterations: 200
  namespacedIterations: true
  namespace: advanced-churn

  churnConfig:
    percent: 15
    duration: 90m
    delay: 1m
    mode: objects

  objects:
  - objectTemplate: critical-config.yml
    replicas: 1
    churn: false

  - objectTemplate: workload.yml
    replicas: 20

  - objectTemplate: service.yml
    replicas: 20
```

### 9. Key Rules and Constraints

✅ Churn only works for create jobs

✅ Requires namespacedIterations: true   

✅ Either cycles or duration must be set  

✅ Churn happens after job completion, before metrics upload   

✅ Works with both namespace-level and object-level deletion.   

❌ Cannot be used with:

* Job types other than `create`.
* Cluster-scoped only objects

### 10. Summary

kube-burner's churning feature allows you to:

✔ Simulate real production instability

✔ Stress test control-plane resilience

✔ Validate cleanup, GC, and reconciliation logic

✔ Detect scaling issues early

✔ Perform chaos-like testing without external tools

It is a first-class primitive for realistic k8s performance testing and should be part of any serious scale or soak test strategy.
