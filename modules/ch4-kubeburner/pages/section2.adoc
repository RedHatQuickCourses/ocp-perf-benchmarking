= Configuring kube-burner jobs to simulate cluster churn

Cluster churn is a critical real-world behavior where workloads are continuously created and deleted. Simulating this behavior helps uncover issues in scheduling, garbage collection, API performance, controller reconciliation, and control-plane stability. kube-burner provides native support for controlled workload churning to model these conditions at scale.

This tutorial walks you through what churn is, how it works, and exactly how to configure it in kube-burner.

== What is churn in kube-burner?

In kube-burner, churn refers to the *cyclic deletion and re-creation of workloads* after the initial job completes.

*Churning*:

 * Randomly selects a subset of namespaces or objects
 * Deletes them
 * Recreates them using the original job templates
 * Repeats this process for a defined duration or number of cycles

*This simulates*:

 * Auto-scaling environments
 * CI/CD redeployments
 * Unstable or bursty workloads
 * Real-world production traffic patterns

NOTE: Churn is supported only for create jobs and only for namespace-based jobs.

== When should you use churn?

You should enable churning when testing:

 * API server behavior under continuous load
 * Scheduler and controller stability
 * Namespace lifecycle performance
 * Garbage collection efficiency
 * Control plane memory and CPU leaks
 * Network and CNI stability under load

Churn is especially valuable for:

 * Long-running soak tests
 * Scale-down/scale-up stress tests
 * Multi-tenant simulation environments

== Basic configuration example

The following example:

 * Creates 100 namespaces
 * Churns 20% of them
 * Runs for 2 hours
 * Recreates 10 Deployments and 10 Services per namespace

```yaml
jobs:
- name: churning-job
  jobIterations: 100
  namespacedIterations: true
  namespace: churn-test

  churnConfig:
    percent: 20
    duration: 2h

  objects:
  - objectTemplate: deployment.yml
    replicas: 10

  - objectTemplate: service.yml
    replicas: 10
```

*What Happens Here?*

1. kube-burner creates 100 namespaces
2. Each namespace gets:
 * 10 Deployments
 * 10 Services
3. After job completion:
 * 20 namespaces (20%) are randomly selected
 * They are deleted and recreated
4. This cycle continues for 2 hours

== Termination conditions

Churn stops when either condition is met first:

* `duration` - Total time to keep churning
* `cycles` - Total number of churn cycles

=== Cycle-based churn

The following configuration churn runs exactly 10 iterations, regardless of time:


```yaml
churnConfig:
  percent: 30
  cycles: 10
```

=== Duration-based churn

Churn runs only by time, ignoring cycles:

```yaml
churnConfig:
  percent: 25
  duration: 1h
  cycles: 0
```

== Delay between cycles

You can pause between churn operations using `delay`:

```yaml
churnConfig:
  percent: 20
  duration: 1h
  delay: 2m
```
Each churn wave waits 2 minutes before starting the next delete/recreate cycle.

== Namespace vs Object modes

By default, kube-burner churns entire namespaces. You can switch to object-level churning with `mode: objects`.

=== Namespace churn (default)

```yaml
churnConfig:
  percent: 20
  mode: namespaces

```
 * Deletes and recreates entire namespaces
 * Heaviest load on API server and controllers

=== Object-level churn

```yaml
churnConfig:
  percent: 20
  mode: objects
```

 * Deletes objects only inside namespaces
 * Namespaces remain intact
 * Better for application-level chaos testing

== Excluding specific objects

Some objects should never be deleted, such as:

 * RBAC
 * CRDs
 * Storage classes
 * Base networking objects

You can disable churn per object:

```yaml
objects:
- objectTemplate: deployment.yml
  replicas: 10
  churn: false

- objectTemplate: service.yml
  replicas: 10
```

The Deployment will never be deleted during churn, but Services will.

== Advanced example

The following configuration:

 * Creates 200 namespaces
 * Churns 15% of them
 * Runs for 90 minutes
 * Waits 1 minute between churn cycles
 * Churns only objects
 * Protects one critical object

```yaml
jobs:
- name: advanced-churn
  jobIterations: 200
  namespacedIterations: true
  namespace: advanced-churn

  churnConfig:
    percent: 15
    duration: 90m
    delay: 1m
    mode: objects

  objects:
  - objectTemplate: critical-config.yml
    replicas: 1
    churn: false

  - objectTemplate: workload.yml
    replicas: 20

  - objectTemplate: service.yml
    replicas: 20
```

== Key rules and constraints

 * Churn only works for create jobs
 * Requires namespaced iterations
 * Either cycles or duration must be set
 * Churn happens after job completion, before the metrics upload
 * Works with both namespace-level and object-level deletion
 * Cannot be used with:
    ** Job types other than `create`
    ** Cluster-scoped only objects

== Summary

kube-burner's churning feature allows you to:

 * Simulate real production instability
 * Stress test control-plane resilience
 * Validate cleanup, GC, and reconciliation logic
 * Detect scaling issues early
 * Perform chaos-like testing without external tools

It is a first-class primitive for realistic k8s performance testing and should be part of any serious scale or soak test strategy.

