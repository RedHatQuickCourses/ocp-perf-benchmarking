<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Measuring control plane responsiveness with kube-burner :: OpenShift performance benchmarking guide</title>
    <link rel="prev" href="index.html">
    <link rel="next" href="section2.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">OpenShift performance benchmarking guide</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/ocp-perf-benchmarking/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="ocp-perf-benchmarking" data-version="1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">OpenShift performance benchmarking guide</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../LABENV/index.html">Lab Environment Setup</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch1-intro/index.html">Introduction to Performance Benchmarking</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-intro/section1.html">Kubernetes/OpenShift performance landscape</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch2-monitoring/index.html">Monitoring OpenShift Performance with the Built-in Stack</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-monitoring/section1.html">Hands-on lab: Exploring the OpenShift monitoring stack</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch3-bench/index.html">Overview of Benchmarking Suites</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch3-bench/section1.html">Kubernetes-native benchmarking tools</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Control Plane and Scalability Testing with kube-burner</a>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="section1.html">Measuring Control Plane Responsiveness</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="section2.html">Configuring kube-burner jobs to simulate cluster churn</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="section3.html">Hands-on with kube-burner</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch5-network/index.html">Understanding Openshift Networking</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch5-network/section1.html">Understanding OVN-Kubernetes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch5-network/section2.html">Network Performance Testing with k8s-netperf</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch5-network/section3.html">Ingress Controller Benchmarking and Analysis</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch6-storage/index.html">Storage benchmarking</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch6-storage/section1.html">Storage performance testing with k8s-IO</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch7-regression/index.html">Automatic performance regression analysis</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch7-regression/section1.html">Hands-on with Orion</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../ch8-final/index.html">Final Review and Key Takeaways</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">OpenShift performance benchmarking guide</span>
    <span class="version">1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">OpenShift performance benchmarking guide</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">OpenShift performance benchmarking guide</a></li>
    <li><a href="index.html">Control Plane and Scalability Testing with kube-burner</a></li>
    <li><a href="section1.html">Measuring Control Plane Responsiveness</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Measuring control plane responsiveness with kube-burner</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This tutorial walks you through configuring and running kube-burner to measure control plane responsiveness using real latency measurements and Prometheus metrics. You will instrument pod and service latency, generate API load, and analyze the results to detect regressions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_understanding_control_plane_metrics"><a class="anchor" href="#_1_understanding_control_plane_metrics"></a>1. Understanding Control Plane Metrics</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Control plane responsiveness reflects how quickly k8s can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create pods</p>
</li>
<li>
<p>Transition pods to ready</p>
</li>
<li>
<p>Make services available</p>
</li>
<li>
<p>Handle API requests under load</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With kube-burner, this is measured using two data sources:</p>
</div>
<div class="sect2">
<h3 id="_a_kube_burner_measurements_built_in"><a class="anchor" href="#_a_kube_burner_measurements_built_in"></a>a. kube-burner Measurements (Built-in)</h3>
<div class="paragraph">
<p>These measure end-to-end latency:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>podLatency</code> → latencies for multiple pod lifecycle events</p>
</li>
<li>
<p><code>serviceLatency</code> → Time taken for service to be up and running</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>They are enabled via:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">global:
  measurements:
    - name: podLatency
    - name: serviceLatency</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_b_prometheus_control_plane_metrics"><a class="anchor" href="#_b_prometheus_control_plane_metrics"></a>b. Prometheus Control Plane Metrics</h3>
<div class="paragraph">
<p>These provide internal system behavior:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API server latency</p>
</li>
<li>
<p>API request rate (QPS)</p>
</li>
<li>
<p>API server CPU usage</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These are scraped using a Prometheus metrics configuration.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_2_utilizing_kube_burner_for_control_plane_testing"><a class="anchor" href="#_2_utilizing_kube_burner_for_control_plane_testing"></a>2. Utilizing kube-burner for Control Plane Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>kube-burner executes high-volume k8s API operations (pod creation, service creation, churn, etc.) while:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Recording latency measurements</p>
</li>
<li>
<p>Scraping Prometheus metrics</p>
</li>
<li>
<p>Producing machine-readable JSON output</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A typical setup includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A job file (job.yaml) for load generation</p>
</li>
<li>
<p>A metrics file (metrics.yaml) for Prometheus scraping</p>
</li>
<li>
<p>One or more object templates (pod.yaml, service.yaml)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3_configure_kube_burner_jobs"><a class="anchor" href="#_3_configure_kube_burner_jobs"></a>3. Configure kube-burner jobs</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_3_1_example_job_yaml_control_plane_load_test"><a class="anchor" href="#_3_1_example_job_yaml_control_plane_load_test"></a>3.1 Example job.yaml (Control Plane Load Test)</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">global:
  measurements:
    - name: podLatency
    - name: serviceLatency

jobs:
  - name: control-plane-load
    jobType: create
    jobIterations: 1
    qps: 50
    burst: 50

    objects:
      - objectTemplate: pod.yaml
        replicas: 500

      - objectTemplate: service.yaml
        replicas: 50</code></pre>
</div>
</div>
<div class="paragraph">
<p>This job:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Creates 500 pods and 50 services</p>
</li>
<li>
<p>Drives load through the k8s API</p>
</li>
<li>
<p>Records pod and service latency automatically</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_3_2_pod_template_pod_yaml"><a class="anchor" href="#_3_2_pod_template_pod_yaml"></a>3.2 Pod Template (pod.yaml)</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">apiVersion: v1
kind: Pod
metadata:
  name: cp-test-pod
  labels:
    app: cp-test
spec:
  containers:
  - name: pause
    image: registry.k8s.io/pause:3.9</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_3_service_template_service_yaml"><a class="anchor" href="#_3_3_service_template_service_yaml"></a>3.3 Service Template (service.yaml)</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">apiVersion: v1
kind: Service
metadata:
  name: cp-test-service
spec:
  selector:
    app: cp-test
  ports:
  - port: 80
    targetPort: 80</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is required for serviceLatency to work correctly.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_4_prometheus_metrics_configuration"><a class="anchor" href="#_4_prometheus_metrics_configuration"></a>4. Prometheus Metrics Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To correlate latency results with control plane behavior, configure Prometheus scraping.</p>
</div>
<div class="sect2">
<h3 id="_4_1_metrics_yaml"><a class="anchor" href="#_4_1_metrics_yaml"></a>4.1 metrics.yaml</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">metricsEndpoints:
- endpoint: http://localhost:9090
  alias: prometheus
  metrics:
  - metrics-control-plane.yaml
  indexer:
    type: local
    metricsDirectory: metrics</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_4_2_control_plane_metrics_metrics_control_plane_yaml"><a class="anchor" href="#_4_2_control_plane_metrics_metrics_control_plane_yaml"></a>4.2 Control Plane Metrics (metrics-control-plane.yaml)</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">- metricName: apiserverP99
  query: histogram_quantile(0.99,
    sum(rate(apiserver_request_duration_seconds_bucket[2m])) by (le))

- metricName: apiserverQPS
  query: sum(rate(apiserver_request_total[2m]))

- metricName: apiserverCPU
  query: sum(irate(process_cpu_seconds_total{job=~".*apiserver.*"}[2m]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>These allow you to correlate:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Pod latency spikes</p>
</li>
<li>
<p>API server latency</p>
</li>
<li>
<p>API server CPU saturation</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_run_the_test"><a class="anchor" href="#_5_run_the_test"></a>5. Run the Test</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Execute kube-burner with both configs:</p>
</div>
<div class="paragraph">
<p><code>kube-burner init -c job.yaml -m metrics.yaml</code></p>
</div>
<div class="paragraph">
<p>During execution:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Pods and services will be created</p>
</li>
<li>
<p>Latency will be recorded</p>
</li>
<li>
<p>Prometheus metrics will be scraped</p>
</li>
<li>
<p>Results will be written to disk</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_analyzing_results"><a class="anchor" href="#_6_analyzing_results"></a>6. Analyzing Results</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_real_pod_latency_per_pod_document"><a class="anchor" href="#_a_real_pod_latency_per_pod_document"></a>a. Real pod-latency per-pod document</h3>
<div class="paragraph">
<p>This is the per-pod document kube-burner indexes for pods that reached <code>Running</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">{
  "timestamp": "2020-11-15T20:28:59.598727718Z",
  "schedulingLatency": 4,
  "initializedLatency": 20,
  "containersReadyLatency": 2997,
  "podReadyLatency": 2997,
  "metricName": "podLatencyMeasurement",
  "uuid": "c40b4346-7af7-4c63-9ab4-aae7ccdd0616",
  "namespace": "kubelet-density",
  "podName": "kubelet-density-13",
  "nodeName": "worker-001",
  "jobName": "create-pods",
  "jobIteration": "2",
  "replica": "3"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Latencies are in milliseconds.</p>
</li>
<li>
<p><code>podReadyLatency`</code> is the end-to-end number you usually care about (API → scheduler → kubelet readiness).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_b_pod_latency_quantiles"><a class="anchor" href="#_b_pod_latency_quantiles"></a>b. Pod-latency quantiles</h3>
<div class="paragraph">
<p>Kube-burner also writes quantiles per condition. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">{
  "quantileName": "Ready",
  "uuid": "23c0b5fd-c17e-4326-a389-b3aebc774c82",
  "P99": 3774,
  "P95": 3510,
  "P50": 2897,
  "max": 3774,
  "avg": 2876.3,
  "timestamp": "2020-11-15T22:26:51.553221077+01:00",
  "metricName": "podLatencyQuantilesMeasurement"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use <code>P50/P95/P99</code> for trend/regression detection (P99 is your high-confidence signal).</p>
</div>
<div class="paragraph">
<p>All the runtime measurements appear more or less in the similar pattern above.</p>
</div>
</div>
<div class="sect2">
<h3 id="_c_prometheus_metric_documents"><a class="anchor" href="#_c_prometheus_metric_documents"></a>c. Prometheus metric documents</h3>
<div class="paragraph">
<p>Each PromQL result kube-burner writes has this shape with a timestamp.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">[
  {
    "timestamp": "2021-06-23T11:50:15+02:00",
    "labels": {
      "instance": "ip-10-0-219-170.eu-west-3.compute.internal",
      "mode": "user"
    },
    "value": 0.3300880234732172,
    "uuid": "&lt;UUID&gt;",
    "query": "sum(irate(node_cpu_seconds_total[2m])) by (mode,instance)",
    "metricName": "nodeCPU"
  },
  ...
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>kube-burner enriches results with uuid, query, and metricName for correlation. Use metricName to identify which PromQL you ran.</p>
</div>
</div>
<div class="sect2">
<h3 id="_7_quick_checklist_what_signals_mean_what_developer_view"><a class="anchor" href="#_7_quick_checklist_what_signals_mean_what_developer_view"></a>7 — Quick checklist: what signals mean what (developer view)</h3>
<div class="ulist">
<ul>
<li>
<p><code>podLatencyQuantilesMeasurement P99</code> (Ready): control-plane slowdown (API/scheduler/kubelet). Check node &amp; apiserver CPU and apiserver request duration.</p>
</li>
<li>
<p><code>svcLatencyQuantiles P99</code>: Endpoints not ready quickly, or network/provider LB delays. Check endpoints and kube-burner-service-latency connectivity logs.</p>
</li>
<li>
<p><code>Prometheus apiserver P99</code>: (PromQL result apiserver_request_duration_seconds quantile) → API server processing time spike. Correlate with achievedQps in jobSummary.</p>
</li>
<li>
<p><code>High jobSummary.achievedQps with high latencies</code>: you pushed cluster beyond what it was tuned for; lower qps/burst for debugging.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note: The above is just an example, but analyzing metrics and debugging for issues is a wide topic.</p>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="index.html">Control Plane and Scalability Testing with kube-burner</a></span>
  <span class="next"><a href="section2.html">Configuring kube-burner jobs to simulate cluster churn</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
